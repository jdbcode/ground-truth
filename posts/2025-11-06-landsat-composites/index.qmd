---
title: "Ditch the Boilerplate: Use Earth Engine's On-the-Fly Landsat Composites"
date: 2025-11-06
author: Justin Braaten
format: html
categories: [Earth Engine, Landsat, Remote Sensing]
---

How much of your Landsat analysis code is just preprocessing? Cloud masking, filtering scenes, mosaicking pixels—it's necessary work, but it's also repetitive boilerplate that clutters your scripts and slows you down.

Good news: Earth Engine generates cloud-free Landsat composites on the fly. Load them like any ImageCollection and skip straight to analysis.

## What You Get

The `LANDSAT/COMPOSITES/C02` collections provide cloud-masked composites at three temporal resolutions—8-day, 32-day, and annual—spanning Landsat 4–9 data from 1984 to present. These are built from USGS Level-2 Surface Reflectance and, after strict quality filtering, use a median compositor within each time window.

Two types of collections:

**Surface Reflectance**: blue, green, red, NIR, SWIR1, SWIR2, thermal surface temperature

- `LANDSAT/COMPOSITES/C02/T1_L2_8DAY`
- `LANDSAT/COMPOSITES/C02/T1_L2_32DAY`
- `LANDSAT/COMPOSITES/C02/T1_L2_ANNUAL`

**Spectral Indices**: BAI, EVI, NBR, NDVI, NDWI (each index in its own collection)

- Example: `LANDSAT/COMPOSITES/C02/T1_L2_8DAY_NDVI`
- Example: `LANDSAT/COMPOSITES/C02/T1_L2_32DAY_BAI`

These save you from writing (and maintaining) the typical cloud masking functions, date filters, and mosaicking logic that otherwise clutter every Landsat workflow.

### How they're made

- Source data: USGS Level-2 Surface Reflectance (Landsat 4–9).
- Unified collections across Landsat 4–9 instruments.
- Temporal compositing: median within each 8‑day, 32‑day, or annual window.
- Strict filtering applied before compositing, including:
    - Limit Landsat 7 to 1999–2017 (orbital drift / scene acquisition time)
    - Omit Landsat 8 data before 2013‑05‑01 (orbit stability)
    - Omit scenes with WRS_ROW ≥ 122 (no nighttime images)
    - Keep only pixels QA‑flagged as clear
    - Omit L4–L7 pixels with ATMOS_OPACITY > 300 (haze)
    - Omit L8–L9 pixels with any QA_AEROSOL issues
    - Omit saturated or out‑of‑bounds pixels

The code that generates these composites is public (see the Earth Engine catalog entry for details and links).

```{python}
import ee
import pandas as pd
import altair as alt
from IPython.display import Image

ee.Initialize(project='ee-braaten')  # Replace with your project ID
```

## Quick Examples

### Annual True-Color Mosaic

```{python}
collection = ee.ImageCollection('LANDSAT/COMPOSITES/C02/T1_L2_ANNUAL') \
    .filterDate('2023-01-01', '2024-01-01')
image = collection.first()

region = ee.Geometry.Rectangle([5.9, 45.8, 10.5, 47.8])
vis = {'bands': ['red', 'green', 'blue'], 'min': 0.0, 'max': 0.25}

# Get thumbnail URL and display
url = image.getThumbURL({
    'region': region,
    'dimensions': 800,
    'format': 'png',
    **vis
})
Image(url=url)
```

No cloud masking function. No pixel compositing logic. Just load and visualize.

### 8-Day NDVI Time Series

```{python}
point = ee.Geometry.Point([-121.5, 38.5])
collection = ee.ImageCollection('LANDSAT/COMPOSITES/C02/T1_L2_8DAY_NDVI') \
    .filterDate('2023-01-01', '2024-01-01')

def extract_ndvi(img):
    date = img.date().format("YYYY-MM-dd")
    ndvi = img.reduceRegion(
        reducer=ee.Reducer.mean(), 
        geometry=point, 
        scale=30
    ).get('NDVI')
    return ee.Feature(None, {'date': date, 'ndvi': ndvi})

timeseries = collection.map(extract_ndvi).getInfo()
rows = [f['properties'] for f in timeseries['features']]
df = pd.DataFrame(rows)
df['date'] = pd.to_datetime(df['date'])

chart = alt.Chart(df).mark_line(point=True).encode(
    x='date:T',
    y=alt.Y('ndvi:Q', title='NDVI'),
    tooltip=['date', 'ndvi']
).properties(
    title='8-Day NDVI (Sacramento Valley, 2023)',
    width=650
)
chart
```

The NDVI is already computed—no band math required. If you need custom indices, use the surface reflectance composites instead.

### Wildfire Burn Severity (dNBR)

```{python}
# Dixie Fire, August 2021
prefire = ee.ImageCollection('LANDSAT/COMPOSITES/C02/T1_L2_32DAY_NBR') \
    .filterDate('2021-06-15', '2021-07-15').mean()
postfire = ee.ImageCollection('LANDSAT/COMPOSITES/C02/T1_L2_32DAY_NBR') \
    .filterDate('2021-08-15', '2021-09-15').mean()

dNBR = prefire.subtract(postfire)

region = ee.Geometry.Rectangle([-122.5, 39.8, -120.5, 40.5])
vis = {'min': -0.1, 'max': 1, 'palette': ['#006400', '#F0E68C', '#8B0000']}

# Get thumbnail URL and display
url = dNBR.getThumbURL({
    'region': region,
    'dimensions': 800,
    'format': 'png',
    **vis
})
Image(url=url)
```

Pre- and post-fire NBR composites already masked and mosaicked. Compute the difference and you're done.

## Why This Matters

Without these composites, a typical Landsat workflow looks like this:

1. Define cloud/shadow masking function
2. Filter raw scenes by date and bounds
3. Map masking function over collection
4. Mosaic or reduce pixels
5. Finally: do the actual analysis

With the composite collections, you skip steps 1–4. That's less code to write, debug, and maintain. It's especially valuable for:

- **Rapid prototyping**: test an idea without boilerplate overhead
- **Teaching**: focus on concepts, not preprocessing mechanics
- **Consistent baselines**: everyone uses the same masking/compositing logic

## Try It

Load `LANDSAT/COMPOSITES/C02/T1_L2_ANNUAL` or one of the index collections in your next script. Check the [Earth Engine Data Catalog](https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_COMPOSITES_C02_T1_L2_ANNUAL) for full documentation on bands, properties, and temporal coverage.

Explore the 8-day or 32-day variants if you need finer temporal resolution. The collections are updated regularly as new Landsat data arrives.
