[
  {
    "objectID": "AGENT_INSTRUCTIONS.html",
    "href": "AGENT_INSTRUCTIONS.html",
    "title": "Ground Truth Blog Agent Instructions",
    "section": "",
    "text": "These guidelines help an AI agent draft new short “b-side” posts for the Ground Truth blog.\n\n\n\nShort, discovery-oriented notes (500–900 words typical).\nConversational, pragmatic, not overly polished; prioritize usefulness.\nEmphasize Earth Engine, geospatial analysis, Python workflows, Google Cloud, public geospatial datasets.\nWhen announcing datasets: include collection ID, a minimal usage snippet, and 1–2 suggested applications.\n\n\n\n\n\nTitle (succinct, action or insight oriented)\n1–2 sentence hook/summary.\nMinimal context (what/why).\nOne or more concise examples (image, chart, or stat table).\nOptional: small troubleshooting tip or gotcha.\nLinks (dataset, docs, code repo, related post).\nClosing nudge (“Try it”, “Explore variants”, etc.).\n\n\n\n\nUse this pattern at the start of posts:\nimport ee\nimport pandas as pd\nimport altair as alt\nfrom IPython.display import Image\n\n# Prefer env var; readers can also hardcode directly if preferred.\nPROJECT_ID = os.environ.get(\"EE_PROJECT_ID\", \"YOUR_PROJECT_ID\")\nee.Initialize(project=PROJECT_ID)\nFor rendering, use the author’s actual project. Readers will replace with their own.\n\n\n\nUse getThumbURL() for displaying Earth Engine images in blog posts:\nurl = image.getThumbURL({\n    'region': region,\n    'dimensions': 800,\n    'format': 'png',\n    **vis_params\n})\nImage(url=url)\n\nSet dimensions to 800 for full-width images\nUse PNG format for best quality\nKeep zoom/region appropriate for the content\nThis approach works reliably with Quarto rendering and shows readers practical EE code\n\n\n\n\nAlways save EE thumbs to local PNGs and display those paths in posts so images stay valid after publish.\nInclude a visible setup chunk with a small helper: ```python from pathlib import Path from urllib.request import urlopen\ndef save_image(url: str, filename: str) -&gt; Path: dest = Path(filename) with urlopen(url) as response, open(dest, “wb”) as fp: fp.write(response.read()) return dest ```\nPattern when rendering images: python     url = image.getThumbURL({...})     save_image(url, 'my_image.png')     Image(url='my_image.png')\nKeep images in the post folder; Quarto will copy them into docs/ during render.\n\n\n\n\n\n\nUse Altair for exploratory charts; inline creation.\nUse width 800 for charts.\nSave Altair charts to PNG for smaller HTML file size: chart.save('filename.png')\nDisplay saved charts with: Image(url='filename.png')\nTitles concise; axes labeled.\nFor time series: convert FeatureCollection to client-side list carefully (limit temporal range).\n\n\n\n\nWhen introducing a dataset: - Collection ID - Spatial/temporal coverage summary - Key bands / properties - One usage code snippet - Attribution / source link\n\n\n\n\nHide setup/auth chunks: #| echo: false\nShow analysis chunks: #| echo: true\nSuppress messages unless relevant: #| message: false\nIf a chunk produces an image or chart only: #| echo: false but keep narrative around it.\n\n\n\n\n\nAll static PNGs must fit container; rely on Quarto CSS (img { max-width: 100%; height: auto; }).\nUse getThumbURL() for Earth Engine image visualization to ensure reliable Quarto rendering.\n\n\n\n\n\n\ncollection = ee.ImageCollection('LANDSAT/COMPOSITES/C02/T1_L2_ANNUAL').filterDate('2023-01-01','2024-01-01')\nimage = collection.first()\nregion = ee.Geometry.Rectangle([5.9, 45.8, 10.5, 47.8])\nvis = {'bands':['red','green','blue'], 'min':0, 'max':0.3}\n\nurl = image.getThumbURL({\n    'region': region,\n    'dimensions': 800,\n    'format': 'png',\n    **vis\n})\nImage(url=url)\n\n\n\npoint = ee.Geometry.Point([-121.5, 38.5])\ncollection = ee.ImageCollection('LANDSAT/COMPOSITES/C02/T1_L2_8DAY_NDVI') \\\n    .filterDate('2023-01-01', '2024-01-01')\n\ndef extract_ndvi(img):\n    date = img.date().format(\"YYYY-MM-dd\")\n    ndvi = img.reduceRegion(\n        reducer=ee.Reducer.mean(),\n        geometry=point,\n        scale=30\n    ).get('NDVI')\n    return ee.Feature(None, {'date': date, 'ndvi': ndvi})\n\ntimeseries = collection.map(extract_ndvi).getInfo()\nrows = [f['properties'] for f in timeseries['features']]\ndf = pd.DataFrame(rows)\ndf['date'] = pd.to_datetime(df['date'])\n\nchart = alt.Chart(df).mark_line(point=True).encode(\n    x=alt.X('date:T', title='Date'),\n    y=alt.Y('ndvi:Q', title='NDVI'),\n    tooltip=['date:T', alt.Tooltip('ndvi:Q', format='.3f')]\n).properties(\n    width=800,\n    height=300\n)\nchart.save('ndvi_chart.png', scale_factor=2.0)\nImage(url='ndvi_chart.png')\n(Agent: ensure performance; for large collections, reduce temporal range.)\n\n\n\n\n\nPrefer active voice (“We load”, “This composite shows”)\nUse short paragraphs (2–4 sentences).\nAvoid marketing fluff; precise technical wording.\nLink dataset IDs with backticks.\n\n\n\n\n\nNo overflowing images.\nAll code executes under current environment.\nTitle and first sentence compelling.\nAt least one visual (image or chart).\nLinks validated.\n\n\n\n\n\nDeep multi-thousand word tutorials.\nComplex multi-stage ETL pipelines (link out instead).\n\n\n\n\nOne index.qmd file in posts/YYYY-MM-DD-slug/ using the template."
  },
  {
    "objectID": "AGENT_INSTRUCTIONS.html#purpose-tone",
    "href": "AGENT_INSTRUCTIONS.html#purpose-tone",
    "title": "Ground Truth Blog Agent Instructions",
    "section": "",
    "text": "Short, discovery-oriented notes (500–900 words typical).\nConversational, pragmatic, not overly polished; prioritize usefulness.\nEmphasize Earth Engine, geospatial analysis, Python workflows, Google Cloud, public geospatial datasets.\nWhen announcing datasets: include collection ID, a minimal usage snippet, and 1–2 suggested applications."
  },
  {
    "objectID": "AGENT_INSTRUCTIONS.html#standard-post-structure",
    "href": "AGENT_INSTRUCTIONS.html#standard-post-structure",
    "title": "Ground Truth Blog Agent Instructions",
    "section": "",
    "text": "Title (succinct, action or insight oriented)\n1–2 sentence hook/summary.\nMinimal context (what/why).\nOne or more concise examples (image, chart, or stat table).\nOptional: small troubleshooting tip or gotcha.\nLinks (dataset, docs, code repo, related post).\nClosing nudge (“Try it”, “Explore variants”, etc.)."
  },
  {
    "objectID": "AGENT_INSTRUCTIONS.html#earth-engine-initialization-python",
    "href": "AGENT_INSTRUCTIONS.html#earth-engine-initialization-python",
    "title": "Ground Truth Blog Agent Instructions",
    "section": "",
    "text": "Use this pattern at the start of posts:\nimport ee\nimport pandas as pd\nimport altair as alt\nfrom IPython.display import Image\n\n# Prefer env var; readers can also hardcode directly if preferred.\nPROJECT_ID = os.environ.get(\"EE_PROJECT_ID\", \"YOUR_PROJECT_ID\")\nee.Initialize(project=PROJECT_ID)\nFor rendering, use the author’s actual project. Readers will replace with their own."
  },
  {
    "objectID": "AGENT_INSTRUCTIONS.html#image-display-guidelines",
    "href": "AGENT_INSTRUCTIONS.html#image-display-guidelines",
    "title": "Ground Truth Blog Agent Instructions",
    "section": "",
    "text": "Use getThumbURL() for displaying Earth Engine images in blog posts:\nurl = image.getThumbURL({\n    'region': region,\n    'dimensions': 800,\n    'format': 'png',\n    **vis_params\n})\nImage(url=url)\n\nSet dimensions to 800 for full-width images\nUse PNG format for best quality\nKeep zoom/region appropriate for the content\nThis approach works reliably with Quarto rendering and shows readers practical EE code\n\n\n\n\nAlways save EE thumbs to local PNGs and display those paths in posts so images stay valid after publish.\nInclude a visible setup chunk with a small helper: ```python from pathlib import Path from urllib.request import urlopen\ndef save_image(url: str, filename: str) -&gt; Path: dest = Path(filename) with urlopen(url) as response, open(dest, “wb”) as fp: fp.write(response.read()) return dest ```\nPattern when rendering images: python     url = image.getThumbURL({...})     save_image(url, 'my_image.png')     Image(url='my_image.png')\nKeep images in the post folder; Quarto will copy them into docs/ during render."
  },
  {
    "objectID": "AGENT_INSTRUCTIONS.html#chart-guidelines",
    "href": "AGENT_INSTRUCTIONS.html#chart-guidelines",
    "title": "Ground Truth Blog Agent Instructions",
    "section": "",
    "text": "Use Altair for exploratory charts; inline creation.\nUse width 800 for charts.\nSave Altair charts to PNG for smaller HTML file size: chart.save('filename.png')\nDisplay saved charts with: Image(url='filename.png')\nTitles concise; axes labeled.\nFor time series: convert FeatureCollection to client-side list carefully (limit temporal range)."
  },
  {
    "objectID": "AGENT_INSTRUCTIONS.html#dataset-announcement-checklist",
    "href": "AGENT_INSTRUCTIONS.html#dataset-announcement-checklist",
    "title": "Ground Truth Blog Agent Instructions",
    "section": "",
    "text": "When introducing a dataset: - Collection ID - Spatial/temporal coverage summary - Key bands / properties - One usage code snippet - Attribution / source link"
  },
  {
    "objectID": "AGENT_INSTRUCTIONS.html#code-chunk-conventions",
    "href": "AGENT_INSTRUCTIONS.html#code-chunk-conventions",
    "title": "Ground Truth Blog Agent Instructions",
    "section": "",
    "text": "Hide setup/auth chunks: #| echo: false\nShow analysis chunks: #| echo: true\nSuppress messages unless relevant: #| message: false\nIf a chunk produces an image or chart only: #| echo: false but keep narrative around it."
  },
  {
    "objectID": "AGENT_INSTRUCTIONS.html#image-sizing-responsiveness",
    "href": "AGENT_INSTRUCTIONS.html#image-sizing-responsiveness",
    "title": "Ground Truth Blog Agent Instructions",
    "section": "",
    "text": "All static PNGs must fit container; rely on Quarto CSS (img { max-width: 100%; height: auto; }).\nUse getThumbURL() for Earth Engine image visualization to ensure reliable Quarto rendering."
  },
  {
    "objectID": "AGENT_INSTRUCTIONS.html#reusable-patterns",
    "href": "AGENT_INSTRUCTIONS.html#reusable-patterns",
    "title": "Ground Truth Blog Agent Instructions",
    "section": "",
    "text": "collection = ee.ImageCollection('LANDSAT/COMPOSITES/C02/T1_L2_ANNUAL').filterDate('2023-01-01','2024-01-01')\nimage = collection.first()\nregion = ee.Geometry.Rectangle([5.9, 45.8, 10.5, 47.8])\nvis = {'bands':['red','green','blue'], 'min':0, 'max':0.3}\n\nurl = image.getThumbURL({\n    'region': region,\n    'dimensions': 800,\n    'format': 'png',\n    **vis\n})\nImage(url=url)\n\n\n\npoint = ee.Geometry.Point([-121.5, 38.5])\ncollection = ee.ImageCollection('LANDSAT/COMPOSITES/C02/T1_L2_8DAY_NDVI') \\\n    .filterDate('2023-01-01', '2024-01-01')\n\ndef extract_ndvi(img):\n    date = img.date().format(\"YYYY-MM-dd\")\n    ndvi = img.reduceRegion(\n        reducer=ee.Reducer.mean(),\n        geometry=point,\n        scale=30\n    ).get('NDVI')\n    return ee.Feature(None, {'date': date, 'ndvi': ndvi})\n\ntimeseries = collection.map(extract_ndvi).getInfo()\nrows = [f['properties'] for f in timeseries['features']]\ndf = pd.DataFrame(rows)\ndf['date'] = pd.to_datetime(df['date'])\n\nchart = alt.Chart(df).mark_line(point=True).encode(\n    x=alt.X('date:T', title='Date'),\n    y=alt.Y('ndvi:Q', title='NDVI'),\n    tooltip=['date:T', alt.Tooltip('ndvi:Q', format='.3f')]\n).properties(\n    width=800,\n    height=300\n)\nchart.save('ndvi_chart.png', scale_factor=2.0)\nImage(url='ndvi_chart.png')\n(Agent: ensure performance; for large collections, reduce temporal range.)"
  },
  {
    "objectID": "AGENT_INSTRUCTIONS.html#writing-style-reminders",
    "href": "AGENT_INSTRUCTIONS.html#writing-style-reminders",
    "title": "Ground Truth Blog Agent Instructions",
    "section": "",
    "text": "Prefer active voice (“We load”, “This composite shows”)\nUse short paragraphs (2–4 sentences).\nAvoid marketing fluff; precise technical wording.\nLink dataset IDs with backticks."
  },
  {
    "objectID": "AGENT_INSTRUCTIONS.html#quality-checklist-before-finish",
    "href": "AGENT_INSTRUCTIONS.html#quality-checklist-before-finish",
    "title": "Ground Truth Blog Agent Instructions",
    "section": "",
    "text": "No overflowing images.\nAll code executes under current environment.\nTitle and first sentence compelling.\nAt least one visual (image or chart).\nLinks validated."
  },
  {
    "objectID": "AGENT_INSTRUCTIONS.html#out-of-scope",
    "href": "AGENT_INSTRUCTIONS.html#out-of-scope",
    "title": "Ground Truth Blog Agent Instructions",
    "section": "",
    "text": "Deep multi-thousand word tutorials.\nComplex multi-stage ETL pipelines (link out instead)."
  },
  {
    "objectID": "AGENT_INSTRUCTIONS.html#final-output",
    "href": "AGENT_INSTRUCTIONS.html#final-output",
    "title": "Ground Truth Blog Agent Instructions",
    "section": "",
    "text": "One index.qmd file in posts/YYYY-MM-DD-slug/ using the template."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ground Truth Blog",
    "section": "",
    "text": "Replicating GOES GeoColor in Earth Engine: A Winter Solstice Showcase\n\n\n\nEarth Engine\n\nGOES\n\nRemote Sensing\n\nPython\n\n\n\n\n\n\n\n\n\nDec 29, 2025\n\n\nJustin Braaten\n\n\n\n\n\n\n\n\n\n\n\n\nDitch the Boilerplate: Use Earth Engine’s On-the-Fly Landsat Composites\n\n\n\nEarth Engine\n\nLandsat\n\nRemote Sensing\n\n\n\n\n\n\n\n\n\nNov 6, 2025\n\n\nJustin Braaten\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2025-11-06-landsat-composites/index.html",
    "href": "posts/2025-11-06-landsat-composites/index.html",
    "title": "Ditch the Boilerplate: Use Earth Engine’s On-the-Fly Landsat Composites",
    "section": "",
    "text": "How much of your Landsat analysis code is just preprocessing? Cloud masking, filtering scenes, mosaicking pixels—it’s necessary work, but it’s also repetitive boilerplate that clutters your scripts and slows you down.\nGood news: Earth Engine generates cloud-free Landsat composites on the fly. Load them like any ImageCollection and skip straight to analysis."
  },
  {
    "objectID": "posts/2025-11-06-landsat-composites/index.html#what-you-get",
    "href": "posts/2025-11-06-landsat-composites/index.html#what-you-get",
    "title": "Ditch the Boilerplate: Use Earth Engine’s On-the-Fly Landsat Composites",
    "section": "What You Get",
    "text": "What You Get\nThe LANDSAT/COMPOSITES/C02 collections provide cloud-masked composites at three temporal resolutions—8-day, 32-day, and annual—spanning Landsat 4–9 data from 1984 to present. These are built from USGS Level-2 Surface Reflectance and, after strict quality filtering, use a median compositor within each time window.\nTwo types of collections:\nSurface Reflectance: blue, green, red, NIR, SWIR1, SWIR2, thermal surface temperature\n\nLANDSAT/COMPOSITES/C02/T1_L2_8DAY\nLANDSAT/COMPOSITES/C02/T1_L2_32DAY\nLANDSAT/COMPOSITES/C02/T1_L2_ANNUAL\n\nSpectral Indices: BAI, EVI, NBR, NDVI, NDWI (each index in its own collection)\n\nExample: LANDSAT/COMPOSITES/C02/T1_L2_8DAY_NDVI\nExample: LANDSAT/COMPOSITES/C02/T1_L2_32DAY_BAI\nExample: LANDSAT/COMPOSITES/C02/T1_L2_ANNUAL_NDVI\n\nThese save you from writing (and maintaining) the typical cloud masking functions, date filters, and mosaicking logic that otherwise clutter every Landsat workflow.\n\nHow they’re made\n\nSource data: USGS Level-2 Surface Reflectance (Landsat 4–9).\nUnified collections across Landsat 4–9 instruments.\nTemporal compositing: median within each 8‑day, 32‑day, or annual window.\nStrict filtering applied before compositing, including:\n\nLimit Landsat 7 to 1999–2017 (orbital drift / scene acquisition time)\nOmit Landsat 8 data before 2013‑05‑01 (orbit stability)\nOmit scenes with WRS_ROW ≥ 122 (no nighttime images)\nKeep only pixels QA‑flagged as clear\nOmit L4–L7 pixels with ATMOS_OPACITY &gt; 300 (haze)\nOmit L8–L9 pixels with any QA_AEROSOL issues\nOmit saturated or out‑of‑bounds pixels"
  },
  {
    "objectID": "posts/2025-11-06-landsat-composites/index.html#a-fire-history-the-dixie-fire-through-landsat-composites",
    "href": "posts/2025-11-06-landsat-composites/index.html#a-fire-history-the-dixie-fire-through-landsat-composites",
    "title": "Ditch the Boilerplate: Use Earth Engine’s On-the-Fly Landsat Composites",
    "section": "A Fire History: The Dixie Fire Through Landsat Composites",
    "text": "A Fire History: The Dixie Fire Through Landsat Composites\nLet’s use these composites to tell the story of California’s 2021 Dixie Fire—the state’s largest single-source wildfire at the time. We’ll examine the landscape before the fire, track vegetation through the burn period, and assess the fire’s impact. All with minimal preprocessing code.\n\n# Define our study area in the northern Sierra Nevada\nregion = ee.Geometry.Rectangle([-121.5, 39.8, -120.5, 40.5])\n\n\nThe Landscape Before: 2020 Annual Composite\nFirst, let’s visualize the pre-fire landscape using a false-color composite (SWIR1, NIR, green) that highlights vegetation structure and moisture content. Healthy vegetation appears green, while exposed soil and rock show brown.\n\nprefire_annual = (ee.ImageCollection('LANDSAT/COMPOSITES/C02/T1_L2_ANNUAL')\n    .filterDate('2020-01-01', '2021-01-01').first())\n\nvis_falsecolor = {\n    'bands': ['swir1', 'nir', 'green'],\n    'min': 0.0,\n    'max': 0.4\n}\n\nurl = prefire_annual.unmask(0).getThumbURL({\n    'region': region,\n    'dimensions': 800,\n    'format': 'png',\n    **vis_falsecolor\n})\nsave_image(url, 'prefire_annual_falsecolor.png')\nImage(url='prefire_annual_falsecolor.png')\n\n\n\n\nThe northern Sierra Nevada in 2020: dense conifer forests, interspersed with meadows and chaparral.\n\n\nMonitoring Vegetation: 8-Day NDVI Through 2021\nTo track forest productivity over the year, we’ll use Dynamic World land cover data from May 2021 to isolate forest pixels, then monitor their NDVI. This gives us a pure forest signal.\n\n# Create forest mask using Dynamic World (pre-fire)\ndw = (ee.ImageCollection('GOOGLE/DYNAMICWORLD/V1')\n    .filterDate('2021-05-01', '2021-06-01')\n    .filterBounds(region)\n    .select('label'))\n\nforest_mask = dw.mode().eq(1)  # Class 1 = trees\n\n# Extract NDVI time series from forest pixels\nndvi_collection = (ee.ImageCollection('LANDSAT/COMPOSITES/C02/T1_L2_8DAY_NDVI')\n    .filterDate('2021-01-01', '2021-12-31'))\n\ndef extract_ndvi(img):\n    date = img.date().format(\"YYYY-MM-dd\")\n    masked = img.updateMask(forest_mask)\n    stats = masked.reduceRegion(\n        reducer=ee.Reducer.mean(),\n        geometry=region,\n        scale=90,\n    )\n    return ee.Feature(None, {\n        'date': date,\n        'NDVI': stats.get('NDVI')\n    })\n\nfeatures = ndvi_collection.map(extract_ndvi)\ndf = ee.data.computeFeatures({\n    'expression': features,\n    'fileFormat': 'PANDAS_DATAFRAME'\n})\ndf['date'] = pd.to_datetime(df['date'])\n\nchart = (\n    alt.Chart(df)\n    .mark_point(filled=True, size=200, color='green')\n    .encode(\n        x=alt.X('date:T', title='Date'),\n        y=alt.Y('NDVI:Q', title='NDVI', scale=alt.Scale(domain=[0, 1])),\n        tooltip=['date:T', alt.Tooltip('NDVI:Q', format='.3f')]\n    )\n).properties(\n    width=800,\n    height=300\n)\nchart.save('ndvi_timeseries.png')\nImage(url='ndvi_timeseries.png')\n\n\n\n\nRegional 8-day NDVI for forest pixels. Some observations may not be available because satellite scheduling or cloud masking.\n\n\nFire Comparison: Before and After\nNow let’s compare the landscape immediately before and after the main burn period using enhanced true‑color (SWIR1–NIR–green) composites.\n\n# Pre-fire composite (May-June 2021)\nprefire_summer = (ee.ImageCollection('LANDSAT/COMPOSITES/C02/T1_L2_32DAY')\n    .filterDate('2021-05-01', '2021-07-01').mean())\n\nvis_enhanced = {\n    'bands': ['swir1', 'nir', 'green'],\n    'min': 0.0,\n    'max': 0.4\n}\n\nurl_prefire = prefire_summer.unmask(0).getThumbURL({\n    'region': region,\n    'dimensions': 800,\n    'format': 'png',\n    **vis_enhanced\n})\nsave_image(url_prefire, 'prefire_summer_enhanced.png')\nImage(url='prefire_summer_enhanced.png')\n\n\n\n\nGreen canopy dominates in early summer 2021, shortly before ignition.\n\n# Post-fire composite (September-October 2021)\npostfire_fall = (ee.ImageCollection('LANDSAT/COMPOSITES/C02/T1_L2_32DAY')\n    .filterDate('2021-09-01', '2021-11-01').mean())\n\nurl_postfire = postfire_fall.unmask(0).getThumbURL({\n    'region': region,\n    'dimensions': 800,\n    'format': 'png',\n    **vis_enhanced\n})\nsave_image(url_postfire, 'postfire_fall_enhanced.png')\nImage(url='postfire_fall_enhanced.png')\n\n\n\n\nBy fall, the burn scar is evident: brown and red tones replace the green canopy where fire consumed over 960,000 acres.\n\n\nBurn Severity: Differenced NBR\nFinally, we’ll quantify burn severity using the Normalized Burn Ratio (NBR). High dNBR values indicate severe fire impact.\n\n# Pre-fire NBR\nprefire_nbr = (ee.ImageCollection('LANDSAT/COMPOSITES/C02/T1_L2_32DAY_NBR')\n    .filterDate('2021-05-01', '2021-07-01').mean())\n\n# Post-fire NBR\npostfire_nbr = (ee.ImageCollection('LANDSAT/COMPOSITES/C02/T1_L2_32DAY_NBR')\n    .filterDate('2021-09-01', '2021-11-01').mean())\n\ndNBR = prefire_nbr.subtract(postfire_nbr)\n\n# Visualization parameters (single-band; no need to specify 'bands')\nvis_dnbr = {\n    'min': -0.1,\n    'max': 1.0,\n    'palette': ['#006400', '#FFFFE0', '#FFA500', '#FF0000', '#8B0000']\n}\n\n# Convert to RGB with palette.\nrgb = dNBR.visualize(**vis_dnbr).unmask(0)\nurl_dnbr = rgb.getThumbURL({\n    'region': region,\n    'dimensions': 800,\n    'format': 'png'\n})\nsave_image(url_dnbr, 'dnbr_map.png')\nImage(url='dnbr_map.png')\n\n\n\n\nDark red shows high-severity burn where complete canopy loss occurred. Yellow-orange indicates moderate severity. Green represents unburned or low-severity areas. The composites provide analysis-ready NBR—no manual index calculation required."
  },
  {
    "objectID": "posts/2025-11-06-landsat-composites/index.html#why-this-matters",
    "href": "posts/2025-11-06-landsat-composites/index.html#why-this-matters",
    "title": "Ditch the Boilerplate: Use Earth Engine’s On-the-Fly Landsat Composites",
    "section": "Why This Matters",
    "text": "Why This Matters\nThe Dixie Fire analysis above required ~50 lines of code. A traditional workflow—cloud masking, mosaicking, computing indices—would take 200+ lines and might require managing intermediate outputs.\nThese composites eliminate preprocessing friction, letting you focus on the science:\n\nMulti-temporal analysis: Track phenology, disturbance, or recovery without wrestling with scene selection\nReproducibility: Everyone uses the same masking/compositing logic, reducing methods variability\nTeaching: Students learn remote sensing concepts, not preprocessing mechanics"
  },
  {
    "objectID": "posts/2025-11-06-landsat-composites/index.html#try-it",
    "href": "posts/2025-11-06-landsat-composites/index.html#try-it",
    "title": "Ditch the Boilerplate: Use Earth Engine’s On-the-Fly Landsat Composites",
    "section": "Try It",
    "text": "Try It\nStart with the LANDSAT/COMPOSITES/C02/T1_L2_ANNUAL collection for baseline mapping. Use 32-day for seasonal monitoring or 8-day when you need to resolve weekly dynamics.\nFor index collections (NDVI, NBR, EVI, etc.), you can skip band math entirely—just load and analyze. The catalog documentation provides full details on temporal coverage and band properties.\nThese collections update as new Landsat data arrives, making them suitable for both historical analysis and near-real-time monitoring."
  },
  {
    "objectID": "posts/2025-11-06-landsat-composites/index.html#setup",
    "href": "posts/2025-11-06-landsat-composites/index.html#setup",
    "title": "Ditch the Boilerplate: Use Earth Engine’s On-the-Fly Landsat Composites",
    "section": "Setup",
    "text": "Setup\nThe examples below run on a Jupyter kernel with Python 3.10+, earthengine-api, pandas, and altair installed. Set EE_PROJECT_ID in your environment or edit PROJECT_ID below to your Earth Engine project before running.\n\nimport ee\nimport pandas as pd\nimport altair as alt\nfrom IPython.display import Image\nfrom pathlib import Path\nfrom urllib.request import urlopen\nimport os\n\n\ndef save_image(url: str, filename: str) -&gt; Path:\n    \"\"\"Download an EE thumb URL to a local PNG so the post can embed it.\"\"\"\n    dest = Path(filename)\n    with urlopen(url) as response, open(dest, \"wb\") as fp:\n        fp.write(response.read())\n    return dest\n\n# Prefer env var; readers can also hardcode directly if preferred.\nPROJECT_ID = os.environ.get(\"EE_PROJECT_ID\", \"YOUR_PROJECT_ID\")\nee.Initialize(project=PROJECT_ID)"
  },
  {
    "objectID": "posts/2025-12-29-goes-geocolor/index.html",
    "href": "posts/2025-12-29-goes-geocolor/index.html",
    "title": "Replicating GOES GeoColor in Earth Engine: A Winter Solstice Showcase",
    "section": "",
    "text": "December 21st marked the winter solstice—the shortest day of the year in the Northern Hemisphere. With 15 hours of darkness across much of the U.S., it’s the perfect time to showcase the GOES GeoColor visualization: seamless transitions from sunlit landscapes to city lights and cloud illumination at night.\nA few years ago, I wrote about working with GOES data in Earth Engine. Since then, the constellation has evolved: GOES-16 and GOES-17 have been replaced by GOES-18 (West, ~137°W) and GOES-19 (East, ~75°W).\nThis post revisits GOES and shows how to replicate CIRA/NOAA’s stunning GeoColor product using Earth Engine’s Python API. We’ll use it to animate 24 hours across the solstice to watch the contiguous United States transition from night to day and back again."
  },
  {
    "objectID": "posts/2025-12-29-goes-geocolor/index.html#what-is-geocolor",
    "href": "posts/2025-12-29-goes-geocolor/index.html#what-is-geocolor",
    "title": "Replicating GOES GeoColor in Earth Engine: A Winter Solstice Showcase",
    "section": "What is GeoColor?",
    "text": "What is GeoColor?\nGeoColor is a composite visualization developed by CIRA (Cooperative Institute for Research in the Atmosphere) that blends true-color daytime imagery with infrared cloud data and nighttime enhancements including city lights and terrain shading. The result is a single, continuous view that works equally well at noon and midnight.\nKey components:\n\nDaytime: Solar-corrected true color with synthetic green band\nNighttime: City lights from VIIRS, terrain shading from ETOPO1, and IR cloud overlay\nTransition: Smooth blending based on solar zenith angle\n\nLet’s recreate GeoColor in Earth Engine using an approximation of the Miller et al., 2020 methods."
  },
  {
    "objectID": "posts/2025-12-29-goes-geocolor/index.html#setup",
    "href": "posts/2025-12-29-goes-geocolor/index.html#setup",
    "title": "Replicating GOES GeoColor in Earth Engine: A Winter Solstice Showcase",
    "section": "Setup",
    "text": "Setup\nThe examples below run on a Jupyter kernel with Python 3.10+, earthengine-api and geemap installed. Set EE_PROJECT_ID in your environment or edit PROJECT_ID below to your Earth Engine project before running.\n\nimport ee\nimport geemap\nfrom IPython.display import Image, display, Markdown\nfrom pathlib import Path\nfrom urllib.request import urlopen\nimport os\nimport math\n\n\ndef save_image(url: str, filename: str) -&gt; Path:\n    \"\"\"Download an EE thumb URL to a local PNG so the post can embed it.\"\"\"\n    dest = Path(filename)\n    with urlopen(url) as response, open(dest, \"wb\") as fp:\n        fp.write(response.read())\n    return dest\n\n# Prefer env var; readers can also hardcode directly if preferred.\nPROJECT_ID = os.environ.get(\"EE_PROJECT_ID\", \"YOUR_PROJECT_ID\")\nee.Initialize(project=PROJECT_ID)"
  },
  {
    "objectID": "posts/2025-12-29-goes-geocolor/index.html#step-1-configuration-and-utilities",
    "href": "posts/2025-12-29-goes-geocolor/index.html#step-1-configuration-and-utilities",
    "title": "Replicating GOES GeoColor in Earth Engine: A Winter Solstice Showcase",
    "section": "Step 1: Configuration and Utilities",
    "text": "Step 1: Configuration and Utilities\nWe’ll start by defining satellite positions and border overlays, then create a utility for applying scale factors from GOES image metadata. Note that we’re including GOES 16 and 17, in case you’re doing historical analysis.\n\n# Satellite longitude positions.\nGOES_LONGITUDES = {\n    '16': -75,   # East (retired)\n    '17': -137,  # West (retired)\n    '18': -137,  # West (operational)\n    '19': -75    # East (operational)\n}\n\n# Border overlay using global administrative boundaries.\nBORDERS_FC = ee.FeatureCollection('WM/geoLab/geoBoundaries/600/ADM1')\nBORDER_IMAGE = ee.Image().byte().paint(BORDERS_FC, 1, 1).visualize(\n    palette=['ffffff'], opacity=0.6\n)\n\ndef apply_scale_factors(image):\n    \"\"\"Apply band-specific scale and offset from image properties.\"\"\"\n    bands = image.bandNames()\n    props = image.toDictionary()\n    \n    def scale_band(band_name):\n        band_str = ee.String(band_name)\n        scale = ee.Number(props.get(band_str.cat('_scale'), 1.0))\n        offset = ee.Number(props.get(band_str.cat('_offset'), 0.0))\n        return image.select([band_str]).multiply(scale).add(offset).rename([band_str])\n    \n    scaled = ee.ImageCollection.fromImages(bands.map(scale_band)).toBands()\n    return ee.Image(scaled.rename(bands)\n        .copyProperties(image, image.propertyNames())\n        .set('system:time_start', image.get('system:time_start')))"
  },
  {
    "objectID": "posts/2025-12-29-goes-geocolor/index.html#step-2-geometry-calculations",
    "href": "posts/2025-12-29-goes-geocolor/index.html#step-2-geometry-calculations",
    "title": "Replicating GOES GeoColor in Earth Engine: A Winter Solstice Showcase",
    "section": "Step 2: Geometry Calculations",
    "text": "Step 2: Geometry Calculations\nGeoColor requires two angle calculations: solar zenith (for day/night blending) and satellite zenith (for atmospheric correction).\n\ndef calculate_sun_zenith(image):\n    \"\"\"Calculate cosine of solar zenith angle for each pixel.\"\"\"\n    time_ms = image.date().millis()\n    year_start = ee.Date.fromYMD(image.date().get('year'), 1, 1).millis()\n    days_since_start = ee.Number(time_ms).subtract(year_start).divide(24 * 60 * 60 * 1000)\n    \n    # Solar declination\n    fractional_year = days_since_start.multiply(2 * math.pi / 365.25)\n    declination = fractional_year.subtract(1.39).sin().multiply(0.4091)\n    \n    # Solar time\n    seconds_in_day = 86400\n    mod_time = ee.Number(time_ms).mod(seconds_in_day * 1000).divide(1000)\n    utc_hour = mod_time.divide(3600)\n    \n    lat_lon = ee.Image.pixelLonLat()\n    lat = lat_lon.select('latitude').multiply(math.pi / 180)\n    lon = lat_lon.select('longitude')\n    \n    solar_time = lon.divide(15).add(utc_hour)\n    hour_angle = solar_time.subtract(12).multiply(15).multiply(math.pi / 180)\n    \n    # Cosine of solar zenith angle\n    cos_sza = lat.sin().multiply(declination.sin()) \\\n        .add(lat.cos().multiply(declination.cos()).multiply(hour_angle.cos()))\n    \n    return cos_sza\n\ndef calculate_sat_zenith_and_air_mass(image, sat_lon):\n    \"\"\"Calculate satellite viewing angle and atmospheric path length.\"\"\"\n    re = 6378.137  # Earth radius (km)\n    h = 42164.16   # Geostationary orbit height (km)\n    r_ratio = re / h\n    \n    lat_lon = ee.Image.pixelLonLat()\n    lat = lat_lon.select('latitude').multiply(math.pi / 180)\n    lon = lat_lon.select('longitude').multiply(math.pi / 180)\n    sat_lon_rad = ee.Number(sat_lon).multiply(math.pi / 180)\n    \n    lon_diff = lon.subtract(sat_lon_rad)\n    cos_beta = lat.cos().multiply(lon_diff.cos())\n    \n    numerator = cos_beta.subtract(r_ratio)\n    denominator = ee.Image(1.0).add(r_ratio**2) \\\n        .subtract(ee.Image(2 * r_ratio).multiply(cos_beta)).sqrt()\n    cos_sat_zenith = numerator.divide(denominator).clamp(-1, 1)\n    \n    air_mass = ee.Image(1.0).divide(cos_sat_zenith).clamp(1.0, 6.0)\n    sat_zenith_deg = cos_sat_zenith.acos().multiply(180 / math.pi)\n    \n    return sat_zenith_deg, air_mass"
  },
  {
    "objectID": "posts/2025-12-29-goes-geocolor/index.html#step-3-daytime-true-color",
    "href": "posts/2025-12-29-goes-geocolor/index.html#step-3-daytime-true-color",
    "title": "Replicating GOES GeoColor in Earth Engine: A Winter Solstice Showcase",
    "section": "Step 3: Daytime True Color",
    "text": "Step 3: Daytime True Color\nThe daytime layer uses GOES bands 1-3 (blue, red, vegetation red edge) to create a synthetic green band, then applies atmospheric haze correction and solar-aware gamma stretching.\n\ndef get_daytime_layer(image, sat_lon, cos_sun):\n    \"\"\"Generate corrected true-color RGB for daytime.\"\"\"\n    img = apply_scale_factors(image)\n    sat_zenith_deg, air_mass = calculate_sat_zenith_and_air_mass(img, sat_lon)\n    \n    # Cloud-modulated haze correction.\n    ir_temp = img.select('CMI_C13')\n    cloud_mod = ir_temp.subtract(233).divide(283 - 233).clamp(0.3, 1.0)\n    \n    b_haze = air_mass.multiply(0.045).add(0.015).multiply(cloud_mod)\n    r_haze = air_mass.multiply(0.022).add(0.005).multiply(cloud_mod)\n    v_haze = air_mass.multiply(0.008).add(0.002).multiply(cloud_mod)\n    \n    b = img.select('CMI_C01').max(0).clamp(0, 1.3).subtract(b_haze).max(0)\n    r = img.select('CMI_C02').max(0).clamp(0, 1.3).subtract(r_haze).max(0)\n    v = img.select('CMI_C03').max(0).clamp(0, 1.3).subtract(v_haze).max(0)\n    \n    # Synthetic green band.\n    g_syn = r.multiply(0.45).add(b.multiply(0.45)).add(v.multiply(0.10))\n    g_hybrid = g_syn.multiply(0.93).add(v.multiply(0.07))\n    \n    def apply_log_stretch(img):\n        clamped = img.clamp(0.01, 1.1)\n        logged = clamped.log().divide(math.log(10))\n        min_log = math.log10(0.01)\n        max_log = math.log10(1.1)\n        normalized = logged.subtract(min_log).divide(max_log - min_log)\n        \n        # Limb correction (darker at edges).\n        sza_clamped = sat_zenith_deg.clamp(0, 80)\n        gamma_sat = ee.Image(0.85).add(ee.Image(0.15).multiply(sza_clamped.divide(80)))\n        \n        # Sunset boost (brighter near terminator).\n        solar_boost = ee.Image(1.0).subtract(cos_sun.clamp(0.1, 1.0)).multiply(0.25)\n        gamma_final = gamma_sat.subtract(solar_boost).max(0.65)\n        \n        return normalized.pow(gamma_final)\n    \n    r_final = apply_log_stretch(r)\n    g_final = apply_log_stretch(g_hybrid)\n    b_final = apply_log_stretch(b)\n    \n    return ee.Image.cat([r_final, g_final, b_final]).rename(['red', 'green', 'blue'])"
  },
  {
    "objectID": "posts/2025-12-29-goes-geocolor/index.html#step-4-nighttime-enhancement",
    "href": "posts/2025-12-29-goes-geocolor/index.html#step-4-nighttime-enhancement",
    "title": "Replicating GOES GeoColor in Earth Engine: A Winter Solstice Showcase",
    "section": "Step 4: Nighttime Enhancement",
    "text": "Step 4: Nighttime Enhancement\nThe nighttime layer combines VIIRS city lights, terrain-shaded elevation, and infrared cloud imagery. This is where GeoColor really shines—literally. Note that the night lights layer is the 2024 median of the VIIRS VCMSLCFG product.\n\n# Static nighttime assets.\nCITY_LIGHTS = ee.ImageCollection(\"NOAA/VIIRS/DNB/MONTHLY_V1/VCMSLCFG\") \\\n    .filterDate('2024-01-01', '2025-01-01').select('avg_rad') \\\n    .median() \\\n    .setDefaultProjection('EPSG:4326', None, 1000)\nDEM = ee.Image(\"NOAA/NGDC/ETOPO1\").select('bedrock')\nNIGHT_BG_BASE = ee.Image.constant([0.06, 0.03, 0.13])\nFOG_COLOR = ee.Image.constant([0.55, 0.75, 0.98])\n\ndef get_nighttime_layer(image):\n    \"\"\"Generate city lights + terrain + IR clouds for nighttime.\"\"\"\n    img = apply_scale_factors(image)\n    \n    # Terrain shading.\n    is_land = DEM.gt(0)\n    n_e = DEM.max(0).divide(10000).clamp(0, 1)\n    terrain_tint = NIGHT_BG_BASE.multiply(ee.Image(1).subtract(n_e)).add(n_e)\n    shading = ee.Terrain.hillshade(DEM.multiply(5), 315, 35).divide(255)\n    shading_soft = shading.multiply(0.3).add(0.7)\n    nightscape = ee.Image.constant([0,0,0]).where(is_land, terrain_tint.multiply(shading_soft))\n    \n    # City lights (log-scaled).\n    lights_log = CITY_LIGHTS.where(CITY_LIGHTS.lte(0), 1e-10).log10()\n    lights_norm = lights_log.subtract(-0.5).divide(2.5).clamp(0, 1)\n    lights_dim = lights_norm.multiply(0.85)\n    lights_mask = lights_dim.gt(0.25)\n    lights_rgb = ee.Image.cat([\n        lights_dim.pow(0.75),  # Red\n        lights_dim.pow(1.25),  # Green\n        lights_dim.pow(2.00)   # Blue (cooler tint)\n    ])\n    \n    # Infrared clouds and fog detection.\n    ir = img.select('CMI_C13')\n    ir_norm = ir.subtract(242).multiply(-1).divide(62).clamp(0, 1)\n    swir = img.select('CMI_C07')\n    diff = ir.subtract(swir)\n    fog_opacity = diff.subtract(1.0).divide(3.0).clamp(0, 1).multiply(ir.gt(240))\n    \n    # Layer composition.\n    canvas = nightscape.where(lights_mask, lights_rgb)\n    canvas = canvas.blend(FOG_COLOR.updateMask(fog_opacity))\n    ir_gray = ee.Image.cat([ir_norm, ir_norm, ir_norm])\n    canvas = canvas.blend(ir_gray.updateMask(ir_norm))\n    \n    return canvas.rename(['red', 'green', 'blue'])"
  },
  {
    "objectID": "posts/2025-12-29-goes-geocolor/index.html#step-5-blending-and-processing",
    "href": "posts/2025-12-29-goes-geocolor/index.html#step-5-blending-and-processing",
    "title": "Replicating GOES GeoColor in Earth Engine: A Winter Solstice Showcase",
    "section": "Step 5: Blending and Processing",
    "text": "Step 5: Blending and Processing\nNow we combine daytime and nighttime layers with a smooth transition based on solar angle, then overlay borders.\n\ndef process_single_image(image, sat_lon):\n    \"\"\"Generate GeoColor composite with borders.\"\"\"\n    # Calculate solar angle.\n    cos_sun = calculate_sun_zenith(image)\n    \n    # Generate base layers.\n    day_layer = get_daytime_layer(image, sat_lon, cos_sun)\n    night_layer = get_nighttime_layer(image)\n    \n    # Blending.\n    day_weight = cos_sun.unitScale(0.1, 0.3).clamp(0, 1).pow(1.5)\n    \n    geocolor = day_layer.multiply(day_weight).add(\n        night_layer.multiply(ee.Image(1).subtract(day_weight))\n    )\n    \n    # Add border overlay.\n    final_vis = geocolor.visualize(min=0, max=1)\n    final_composite = final_vis.blend(BORDER_IMAGE)\n    \n    return final_composite.copyProperties(image, ['system:time_start'])\n\ndef get_goes_collection(collection_id, start_date, end_date, step=1):\n    \"\"\"\n    Generate processed GeoColor collection with optional frame skipping.\n    \n    Args:\n        collection_id: e.g., \"NOAA/GOES/19/MCMIPF\"\n        start_date: ISO string\n        end_date: ISO string\n        step: Frame skip interval (1=every frame, 2=every 2nd frame, etc.)\n    \"\"\"\n    # Parse satellite ID\n    sat_id = collection_id.split('/')[2]\n    sat_lon = GOES_LONGITUDES.get(sat_id)\n    \n    if sat_lon is None:\n        raise ValueError(f\"Unknown GOES ID '{sat_id}'\")\n    \n    # Load and optionally subsample collection.\n    raw_col = ee.ImageCollection(collection_id).filterDate(start_date, end_date)\n    \n    if step &gt; 1:\n        col_list = raw_col.toList(raw_col.size())\n        sliced_list = col_list.slice(0, None, step)\n        raw_col = ee.ImageCollection.fromImages(sliced_list)\n    \n    return raw_col.map(lambda img: process_single_image(img, sat_lon))"
  },
  {
    "objectID": "posts/2025-12-29-goes-geocolor/index.html#a-midday-example",
    "href": "posts/2025-12-29-goes-geocolor/index.html#a-midday-example",
    "title": "Replicating GOES GeoColor in Earth Engine: A Winter Solstice Showcase",
    "section": "A Midday Example",
    "text": "A Midday Example\nLet’s render a single GeoColor frame from midday on the solstice to see the result before animating.\n\n# Get a single image.\nsingle_col = get_goes_collection(\n    \"NOAA/GOES/19/MCMIPF\",\n    '2025-12-21T16:00',\n    '2025-12-21T16:15',\n    step=1\n)\n\nsingle_image = single_col.first()\n\n# Define region (CONUS).\nroi = ee.Geometry.Rectangle([-125.0, 24.0, -66.0, 50.0], None, False)\n\nurl = single_image.getThumbURL({\n    'region': roi,\n    'dimensions': 800,\n    'format': 'png',\n    'crs': 'EPSG:5070'\n})\n\noutput_image = 'goes_midday.png'\nsave_image(url, output_image)\n\n\n# Display the midday image.\nImage(url='goes_midday.png')\n\n\n\n\nThe synthetic green band creates natural-looking vegetation, atmospheric correction reduces haze, and state borders provide geographic context. In the upper left you can see the nightime begin to fade to day."
  },
  {
    "objectID": "posts/2025-12-29-goes-geocolor/index.html#creating-the-solstice-animation",
    "href": "posts/2025-12-29-goes-geocolor/index.html#creating-the-solstice-animation",
    "title": "Replicating GOES GeoColor in Earth Engine: A Winter Solstice Showcase",
    "section": "Creating the Solstice Animation",
    "text": "Creating the Solstice Animation\nNow for the main event: 24 hours across the winter solstice, watching illumination across CONUS at the annual northern hemisphere minimum. Here we use geemap to download the GIF and add a time stamp to each frame and a progress bar to the bottom. Note that geemap.download_ee_video calls ee.ImageCollection.getVideoThumbURL which has a limit on pixels/download size. If you require larger downloads, see the export to Google Cloud Storage section below or manage downloading and rendering frames with your own system.\n\n# Define animation parameters.\nroi = ee.Geometry.Rectangle([-125.0, 24.0, -66.0, 50.0], None, False)  # CONUS\nstart_date = '2025-12-21T04:30'  # Pre-dawn\nend_date = '2025-12-22T04:30'    # Next morning\nskip_step = 2  # Every 20 minutes (GOES-19 full disk = 10 min cadence)\n\n# Generate collection.\ngoes_col = get_goes_collection(\n    \"NOAA/GOES/19/MCMIPF\",\n    start_date,\n    end_date,\n    step=skip_step\n)\n\n# Add timestamp labels.\ndef add_readable_time(img):\n    date = ee.Date(img.get('system:time_start'))\n    return img.set('label', date.format('yyyy-MM-dd HH:mm').cat(' UTC'))\n\ngoes_col = goes_col.map(add_readable_time)\n\n# Download and create GIF (disabled during site render)\noutput_gif = 'goes_solstice_animation.gif'\n\nvideo_args = {\n    'dimensions': 800,\n    'region': roi,\n    'framesPerSecond': 1,\n    'crs': 'EPSG:5070'\n}\n\ngeemap.download_ee_video(goes_col, video_args, output_gif)\n\ngeemap.add_text_to_gif(\n    output_gif,\n    output_gif,\n    xy=('3%', '5%'),\n    text_sequence=goes_col.aggregate_array('label').getInfo(),\n    font_size=20,\n    font_color='white',\n    duration=100\n)\n\n\n# Display the animation.\ndisplay(Markdown('![](goes_solstice_animation.gif)'))\n\n\n\n\n\n\n\n\nWatch as morning light sweeps westward across the Atlantic, cities fade into daylight, the sun reaches its low arc across the southern sky, and by late afternoon the eastern seaboard is already dark. City lights bloom and western cities remain visible until the Pacific coast finally succumbs to night.\nThe extended darkness showcases GeoColor’s unique nighttime representation, and the rapid transitions at the solstice create dramatic temporal dynamics.\nThe code above works identically for GOES-18 by changing the collection ID—just swap 19 for 18 to see the western hemisphere view."
  },
  {
    "objectID": "posts/2025-12-29-goes-geocolor/index.html#whats-new-since-2021",
    "href": "posts/2025-12-29-goes-geocolor/index.html#whats-new-since-2021",
    "title": "Replicating GOES GeoColor in Earth Engine: A Winter Solstice Showcase",
    "section": "What’s New Since 2021",
    "text": "What’s New Since 2021\nWhen I last wrote about GOES in Earth Engine, GOES-16 and GOES-17 were operational. Here’s what’s changed:\n\nGOES-18 replaced GOES-17 (West) in January 2023, fixing the cooling system issues that plagued GOES-17\nGOES-19 launched June 25, 2024, became operational April 2025, replacing GOES-16 (East)\nBoth satellites provide improved calibration and extended operational lifespans\nEarth Engine collection IDs follow the same pattern: NOAA/GOES/{satellite}/MCMIPF for full disk\n\nThe code above works identically for GOES-18 by changing the collection ID—just swap 19 for 18 to see the western hemisphere view."
  },
  {
    "objectID": "posts/2025-12-29-goes-geocolor/index.html#complete-code-and-export-options",
    "href": "posts/2025-12-29-goes-geocolor/index.html#complete-code-and-export-options",
    "title": "Replicating GOES GeoColor in Earth Engine: A Winter Solstice Showcase",
    "section": "Complete Code and Export Options",
    "text": "Complete Code and Export Options\nThe full implementation is available as a GitHub Gist and Google Colab notebook for easy experimentation.\nFor high-resolution exports, use Earth Engine’s batch export to Google Cloud Storage:\n\ntask = ee.batch.Export.video.toCloudStorage(\n    collection=goes_col,\n    description='goes_geocolor_solstice',\n    bucket='your-bucket-name',  # &lt;-- Replace with your GCS bucket name\n    fileNamePrefix='ee_exports/goes_geocolor_solstice',  # &lt;-- Edit as needed\n    dimensions=1280,\n    framesPerSecond=12,\n    region=roi,\n    crs='EPSG:5070'\n)\ntask.start()"
  },
  {
    "objectID": "posts/2025-12-29-goes-geocolor/index.html#why-this-matters",
    "href": "posts/2025-12-29-goes-geocolor/index.html#why-this-matters",
    "title": "Replicating GOES GeoColor in Earth Engine: A Winter Solstice Showcase",
    "section": "Why This Matters",
    "text": "Why This Matters\nGeoColor transforms GOES from a meteorological workhorse into a visual storytelling platform. The algorithm’s thoughtful design—terrain-aware nighttime rendering, solar-corrected color balance, seamless transitions—creates imagery that’s both scientifically accurate and aesthetically compelling.\nWith GOES-18 and GOES-19 now operational and streaming into Earth Engine, you can:\n\nMonitor severe weather in near real-time\nCreate custom visualizations for public outreach\nAnalyze diurnal patterns in cloud cover, fire behavior, or coastal fog\nBuild time-aware composites that respect day/night boundaries\n\nThe winter solstice offers a perfect testing ground: maximum nighttime coverage, dramatic lighting transitions, and a reminder that Earth Engine’s data catalog extends far beyond Landsat and Sentinel."
  },
  {
    "objectID": "posts/2025-12-29-goes-geocolor/index.html#try-it",
    "href": "posts/2025-12-29-goes-geocolor/index.html#try-it",
    "title": "Replicating GOES GeoColor in Earth Engine: A Winter Solstice Showcase",
    "section": "Try It",
    "text": "Try It\nExplore the GOES-19 Full Disk collection in the Earth Engine Data Catalog. Modify the date range, adjust the blending parameters, or try the CONUS collection (NOAA/GOES/19/MCMIPC) for 5-minute updates over North America."
  },
  {
    "objectID": "posts/2025-12-29-goes-geocolor/index.html#what-is-goes",
    "href": "posts/2025-12-29-goes-geocolor/index.html#what-is-goes",
    "title": "Replicating GOES GeoColor in Earth Engine: A Winter Solstice Showcase",
    "section": "What is GOES?",
    "text": "What is GOES?\nGOES (Geostationary Operational Environmental Satellite) is a series of weather satellites operated by NOAA and NASA that provide continuous monitoring of Earth’s western hemisphere from a fixed position in geostationary orbit, delivering data for storm tracking, weather forecasting, and climate research. The imaging cadence is between 30 seconds and 10 minutes, depending on the data product. Earth Engine ingests images as soon as they are available, with latency under an hour. Earth Engine offers the Cloud and Moisture Imagery (CMI) and Fire/Hotspot Characterization (FHS) products."
  }
]